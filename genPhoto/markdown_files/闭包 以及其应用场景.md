### 定义

闭包是一个**函数**，这个函数能够访问它的词法作用域中的变量，即使这个函数在词法作用域之外执行时，仍然可以访问到这些变量。

```javascript
function outerFunction() {
  let outerVariable = 'I am outside!';

  function innerFunction() {
    console.log(outerVariable); // 访问外部函数的变量
  }

  return innerFunction;
}

const closure = outerFunction(); // outerFunction 执行后返回 innerFunction
closure(); // 输出: 'I am outside!'
```

> 在这个示例中，`innerFunction` 是一个闭包，因为它能够访问到外部函数 `outerFunction` 中的变量 `outerVariable`，即使 `outerFunction` 已经执行完毕。

### 闭包的核心要点：

- **函数内部嵌套函数**：闭包通常出现在一个函数内部定义另一个函数的场景中。

- **保留作用域**：即使外部函数执行结束后，内部函数依然能够访问外部函数的变量。

- **返回内部函数**：闭包常常通过返回内部函数来创建。

```javascript
function f1() {
  var n = 999; // f1 函数作用域内的变量
  
  function f2() {
    console.log(n); // 在 f2 中访问 n
  }
  
  return f2; // 返回 f2 函数，而不是立即执行
}

var n = 998; // 全局变量 n
var result = f1(); // 调用 f1，返回 f2 函数，并将其赋值给 result
result(); // 执行 result，也就是 f2 函数

```

当你调用 `f1()` 时，`f1` 函数返回了 `f2` 函数。然而，`f2` 函数并没有立即执行，它被赋值给了 `result` 变量。当 `f1` 函数执行完毕后，它的作用域并没有被完全销毁，因为 `f2` 函数引用了 `f1` 函数作用域中的变量 `n`。因此，`f1` 的作用域被保留了下来，这就是 **闭包** 的本质。

### 应用场景

#### 数据封装与私有变量

```javascript
function createCounter() {
 let count = 0;

 function increment() {
 	count++;
 	return count;
 }

 return increment;
}

const counter1 = createCounter();

console.log(counter1()); // 输出: 1
console.log(counter1()); // 输出: 2

// 由于 count 变量在闭包中是私有的，因此外部无法访问
// console.log(count); // ReferenceError
```

#### 保留状态的事件处理程序

`JavaScript` 在交互式网页应用中大量依赖事件处理。当为 `DOM` 元素附加事件监听器时，我们经常需要处理程序函数能够访问特定于元素或其上下文的数据。闭包在这种情况下非常有用。通过在另一个函数中创建事件处理程序函数，并且该函数能够访问相关数据，我们可以确保处理程序在外部函数执行完毕后仍然保留这些数据。

```javascript
function createGreeter(name) {
  function greet() {
    console.log("Hello, " + name + "!");
  }

  return greet;
}

const button1 = document.getElementById("button1");
const button2 = document.getElementById("button2");

button1.addEventListener("click", createGreeter("Alice"));
button2.addEventListener("click", createGreeter("Bob"));
```

`createGreeter` 函数接收一个 `name` 参数并定义了一个内部函数 `greet`。当 `createGreeter` 被调用时，它创建了一个闭包，捕获了特定的 `name` 值。然后 `greet` 函数被返回，从而允许它作为事件处理程序被分配。

当按钮被点击时，所对应的事件处理程序函数（由 `createGreeter` 返回）会被执行。由于处理程序函数是闭包的一部分，它能够访问捕获的 `name` 变量，即使 `createGreeter` 已经执行完毕。这确保了每个按钮点击都会触发带有特定名称的问候信息。

- 如果直接在 `createGreeter` 内使用 `console.log(name)`

```javascript
function createGreeter(name) {
  console.log("Hello, " + name + "!");
}

const button1 = document.getElementById("button1");
const button2 = document.getElementById("button2");

button1.addEventListener("click", createGreeter("Alice"));
button2.addEventListener("click", createGreeter("Bob"));
```

在这种情况下，`createGreeter` 函数会立即执行，并在函数调用时输出 `Hello, Alice!` 或 `Hello, Bob!`。**然而，事件处理函数绑定时 `createGreeter` 的返回值是 `undefined`，因此点击按钮时不会再输出任何信息。**

#### 模块和函数柯里化

```javascript
function createMathModule() {
  const PI = 3.14159;

  function add(a, b) {
    return a + b;
  }

  function multiply(a, b) {
    return a * b;
  }

  return {
    add,
    multiply,
  };
}

const mathModule = createMathModule();

console.log(mathModule.add(2, 3)); // 输出: 5
console.log(mathModule.multiply(4, 5)); // 输出: 20

// PI 变量在这里无法直接访问，因为它是闭包的私有变量
// console.log(PI); // ReferenceError
```

`createMathModule` 函数定义了一个常量 `PI` 和两个数学函数 `add` 和 `multiply`。这些函数和常量都封装在 `createMathModule` 调用时创建的闭包中。函数返回一个包含引用的对象，创建了一个私有的命名空间。

#### 函数柯里化

```javascript
// 柯里化函数
function curry(func) {
    return function curried(...args) {
        if (args.length >= func.length) {
            return func(...args);
        } else {
            return function(...moreArgs) {
                return curried(...args, ...moreArgs);
            };
        }
    };
}

// 普通的加法函数
function add(a, b, c) {
    return a + b + c;
}

// 使用柯里化函数包装普通的加法函数
const curriedAdd = curry(add);

// 调用方式
console.log(curriedAdd(1)(2)(3)); // 输出 6
console.log(curriedAdd(1, 2)(3)); // 输出 6
console.log(curriedAdd(1)(2, 3)); // 输出 6
```

#### `Memoization`

`Memoization`是一种优化技术，用于存储函数调用的结果，以避免重复计算。闭包非常适合实现`Memoization`功能，因为它允许函数记住先前计算的值，基于其参数进行存储。

```javascript
function fibonacciMemoized(n) {
  const cache = {};

  function fibonacci(n) {
    if (n === 0 || n === 1) {
      return n;
    }

    if (cache[n]) {
      return cache[n];
    }

    const result = fibonacci(n - 1) + fibonacci(n - 2);
    cache[n] = result;
    return result;
  }

  return fibonacci(n);
}

console.log(fibonacciMemoized(5)); // 输出: 5 (计算并存储在缓存中)
console.log(fibonacciMemoized(5)); // 输出: 5 (从缓存中检索，无需重新计算)
```

`fibonacciMemoized` 函数创建了一个闭包，存储一个缓存对象 `cache`，用于保存先前计算的斐波那契数值。内部函数 `fibonacci` 接受一个 `n` 参数，并检查是否为基数（0 和 1）。

如果 `n` 不是基数并且结果尚未存储在缓存中，则该函数会使用 `fibonacci(n - 1)` 和 `fibonacci(n - 2)` 递归计算斐波那契值。然后将计算结果存储在缓存中以供将来使用。最终，函数返回斐波那契值。

#### 部分应用（Partial Application）

部分应用是一种技术，用于将一个具有多个参数的函数转换为一系列函数，每个函数接收一个参数。这使得我们可以预设函数的部分参数，同时保留其他参数以供以后调用。闭包在实现部分应用中非常有用，因为它们允许创建新的函数，这些函数捕获了原始函数的一组特定参数。

```javascript
function formatMoney(prefix = "$", precision = 2) {
  return function(number) {
    return prefix + number.toFixed(precision);
  }
}

const usdFormatter = formatMoney("$", 2);
const eurFormatter = formatMoney("€", 3);

console.log(usdFormatter(123.456)); // 输出: $123.46
console.log(eurFormatter(789.0123)); // 输出: €789.012
```

`formatMoney` 函数接收两个可选参数：`prefix`（默认为"$"）和 `precision`（默认为2）。它返回一个内部函数，该函数接收一个参数（`number`）。这个内部函数使用闭包捕获的 `prefix` 和 `precision` 值，将提供的数字格式化为指定的小数位数和前缀。

通过使用特定的 `prefix` 和 `precision` 调用 `formatMoney`，我们创建了新的函数，如 `usdFormatter` 和 `eurFormatter`。这些新函数是原始 `formatMoney` 函数的部分应用版本，其中货币符号和小数位数已被预设。

### 命名空间和避免变量冲突

在 `JavaScript` 中，声明在全局作用域的变量可以在整个应用程序中访问。这可能会导致命名冲突，尤其是在大型项目中，涉及多个开发人员时。闭包提供了一种创建私有命名空间的机制，有效地将变量和函数隔离在特定的作用域内。

```javascript
function createNamespace(name) {
  const namespace = {};

  function addToNamespace(key, value) {
    namespace[key] = value;
  }

  return {
    addToNamespace,
    // 可以在这里添加特定于命名空间的函数或变量
    greet: function() {
      console.log("Hello from " + name + " namespace!");
    }
  };
}

const mathNamespace = createNamespace("Math");
mathNamespace.addToNamespace("PI", 3.14159);

const utilNamespace = createNamespace("Util");
utilNamespace.addToNamespace("formatDate", function(date) {
  // 日期格式化逻辑在这里
});

mathNamespace.greet(); // 输出: Hello from Math namespace!
// console.log(mathNamespace.PI); // 会导致错误，因为 PI 是私有的

utilNamespace.formatDate(new Date()); // 调用日期格式化函数
```

#### 迭代器和生成器

`JavaScript` 的迭代器和生成器是处理数据序列的强大工具。闭包在它们的实现中发挥了关键作用。迭代器提供了一种逐个访问集合元素的方法，而生成器是可以暂停执行并按需返回值的函数。

```javascript
function createNumberIterator(start, end) {
  let current = start - 1;

  function next() {
    current++;
    if (current <= end) {
      return { value: current, done: false };
    } else {
      return { done: true };
    }
  }

  return {
    next,
  };
}

const numberIterator = createNumberIterator(1, 5);

console.log(numberIterator.next()); // 输出: { value: 1, done: false }
console.log(numberIterator.next()); // 输出: { value: 2, done: false }
// ... 重复调用 next() 以迭代数字

// 生成器函数示例（类似概念，使用 yield）
function* generatePrimes(max) {
  let num = 2;
  while (num <= max) {
    yield num;
    num++;
    // 这里可以放置素数检查逻辑（为了简化省略）
  }
}

const primeGenerator = generatePrimes(10);

console.log(primeGenerator.next()); // 输出: { value: 2, done: false }
console.log(primeGenerator.next()); // 输出: { value: 3, done: false }
// ... 重复调用 next() 以获取素数
```

#### 带配置的函数工厂

`JavaScript` 函数非常灵活。闭包允许我们创建函数工厂，根据初始配置生成具有自定义行为的新函数。这种模式适用于创建具有可重用核心逻辑但可配置选项的函数。

```javascript
function createLogger(logLevel = "info") {
  const logLevels = {
    debug: console.debug,
    info: console.info,
    warn: console.warn,
    error: console.error,
  };

  function log(message) {
    if (logLevels[logLevel] && logLevel !== "debug" || logLevel === "debug" && process.env.NODE_ENV !== "production") {
      logLevels[logLevel](message);
    }
  }

  return log;
}

const infoLogger = createLogger("info");
const errorLogger = createLogger("error");
const debugLogger = createLogger("debug"); // 仅在非生产环境中记录日志

infoLogger("Informational message");
errorLogger("Error message!");

// 仅当 process.env.NODE_ENV 设置为非“production”时，调试消息才会被记录
debugLogger("Debug message");
```

#### 模块扩展

`JavaScript` 模块允许代码组织和封装。然而，在某些情况下，我们可能希望在不修改原始代码的情况下扩展现有模块的功能。闭包在这方面非常有用，它支持一种称为模块扩展的技术。

```javascript
// 原始模块 (mathModule.js)
export function add(a, b) {
  return a + b;
}

export function subtract(a, b) {
  return a - b;
}

// 模块扩展 (app.js)
import * as math from "./mathModule.js";

function multiply(a, b) {
  return a * b;
}

// 使用闭包扩展 math 模块，通过添加 multiply 函数
(function(math) {
  math.multiply = multiply;
})(math);

console.log(math.add(5, 3)); // 输出: 8（来自原始模块）
console.log(math.multiply(4, 2)); // 输出: 8（添加的功能）

// 原始 mathModule.js 保持不变
```

**解释：**

第一个文件（`mathModule.js`）定义了一个模块，包含两个函数：`add` 和 `subtract`。这些函数被导出以供其他模块使用。第二个文件（`app.js`）使用 `import * as math from "./mathModule.js"` 导入整个 `mathModule`。然后，它定义了一个新的 `multiply` 函数用于乘法。关键部分是立即调用函数表达式（IIFE）。这个匿名函数包裹了扩展模块的逻辑。它将导入的 `math` 对象作为参数。在 IIFE 内部，将新函数 `multiply` 添加到 `math` 对象上，从而有效地扩展了其功能，而无需修改原始代码。

在这种情况下，闭包发挥了重要作用。IIFE 创建了一个私有作用域来处理扩展逻辑。通过在闭包内将 `multiply` 函数赋值给 `math.multiply`，我们扩展了导入的 `math` 模块的功能，而没有修改其原始代码。

#### 防抖和节流用户输入

```javascript
function debounce(func, delay) {
  let timeout;

  return function(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}

const searchInput = document.getElementById("searchInput");

const debouncedSearch = debounce(function(searchTerm) {
  console.log("Search for:", searchTerm);
}, 500); // 延迟500毫秒后执行

searchInput.addEventListener("keyup", function(event) {
  debouncedSearch(event.target.value);
});

// 用户输入 "h" 然后停顿...
// 用户输入 "e" 然后停顿...（延迟执行）
// 经过500毫秒的不活动后，搜索函数将以整个搜索词 "he" 被调用
```
