## 联合类型（Union Types）

### 什么是联合类型

**联合类型**允许一个变量具有多种可能的类型。通过使用竖线 (`|`) 分隔不同的类型，TypeScript 能够表示一个变量可以是这些类型中的任意一种。这在需要变量可以接受多种类型值的场景中非常有用。

### 联合类型的语法

```typescript
let variable: Type1 | Type2 | Type3;
```

### 示例 1：基本使用

```typescript
let value: string | number;

value = "Hello"; // 合法
value = 42;      // 合法
// value = true; // 错误: 布尔类型不在联合类型中
```

### 示例 2：函数参数中的联合类型

```typescript
function printId(id: string | number) {
    console.log(`ID: ${id}`);
}

printId("abc123"); // 输出: ID: abc123
printId(101);      // 输出: ID: 101
```

### 示例 3：联合类型与类型保护

当使用联合类型时，常常需要通过类型保护（Type Guards）来区分具体的类型，以确保类型安全。

```typescript
function formatValue(value: string | number): string {
    if (typeof value === "string") {
        return `String: ${value.toUpperCase()}`;
    } else {
        return `Number: ${value.toFixed(2)}`;
    }
}

console.log(formatValue("hello")); // 输出: String: HELLO
console.log(formatValue(3.14159)); // 输出: Number: 3.14
```

### 示例 4：联合类型与接口

```typescript
interface Bird {
    fly(): void;
    layEggs(): void;
}

interface Fish {
    swim(): void;
    layEggs(): void;
}

type Pet = Bird | Fish;

function getPet(): Pet {
    // 返回一个 Bird 或 Fish 的实例
}

let pet = getPet();

pet.layEggs(); // 合法，因为 layEggs 存在于 Bird 和 Fish 中
// pet.swim();  // 错误: 可能是 Bird，不一定有 swim 方法
```

## 交叉类型（Intersection Types）

### 什么是交叉类型

**交叉类型**将多个类型合并为一个类型，要求该类型同时具备所有合并类型的特性。通过使用 `&` 符号，TypeScript 能够创建一个包含所有交叉类型成员的新类型。这在需要组合多个类型的属性或方法时非常有用。

### 交叉类型的语法

```typescript
type CombinedType = Type1 & Type2 & Type3;
```

### 示例 1：基本使用

```typescript
interface Person {
    name: string;
    age: number;
}

interface Employee {
    employeeId: number;
    department: string;
}

type EmployeePerson = Person & Employee;

let employee: EmployeePerson = {
    name: "Alice",
    age: 30,
    employeeId: 1234,
    department: "Engineering"
};
```

### 示例 2：函数返回值中的交叉类型

```typescript
function extend<T, U>(first: T, second: U): T & U {
    let result = {} as T & U;
    for (let key in first) {
        if (first.hasOwnProperty(key)) {
            (result as any)[key] = first[key];
        }
    }
    for (let key in second) {
        if (second.hasOwnProperty(key)) {
            (result as any)[key] = second[key];
        }
    }
    return result;
}

const person = { name: "Bob" };
const job = { role: "Developer" };
const employee = extend(person, job);

console.log(employee); // 输出: { name: "Bob", role: "Developer" }
```

### 示例 3：交叉类型与类

```typescript
interface CanRun {
    run(): void;
}

interface CanJump {
    jump(): void;
}

class Athlete implements CanRun, CanJump {
    run() {
        console.log("Running...");
    }
    jump() {
        console.log("Jumping...");
    }
}

type AthleticPerson = CanRun & CanJump;

let athlete: AthleticPerson = new Athlete();
athlete.run();  // 输出: Running...
athlete.jump(); // 输出: Jumping...
```