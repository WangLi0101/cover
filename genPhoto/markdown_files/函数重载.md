### JavaScript 中的函数重载

函数重载是指在同一个作用域内定义多个名称相同但参数列表不同（参数类型、参数个数或参数顺序）的函数。当调用这个函数名时，系统会根据传入的参数类型和数量来决定应该执行哪个函数。
JavaScript 本身不支持真正的函数重载，因为 JavaScript 函数可以接受任意数量的参数，并且不会根据参数类型或数量进行区分。但是，我们可以通过多种方式在 JavaScript 中模拟函数重载的行为。

#### 为什么需要函数重载

1. **提高代码可读性** - 使用相同的函数名表示相似的操作
2. **增强开发体验** - 在IDE中可以获得更好的类型提示
3. **灵活处理不同输入** - 为不同类型的输入提供专门的实现
4. **简化API设计** - 减少函数命名的复杂性

#### JavaScript模拟重载的常用方法

##### 1. 判断参数类型和数量

最基本的方法是在函数内部判断参数的类型和数量：

```js
function process(a, b) {
  // 根据参数类型和数量判断
  if (arguments.length === 1) {
    if (typeof a === "number") {
      return a * a; // 计算平方
    } else if (typeof a === "string") {
      return a.toUpperCase(); // 转大写
    }
  } else if (arguments.length === 2) {
    if (typeof a === "number" && typeof b === "number") {
      return a + b; // 数值相加
    } else if (typeof a === "string" && typeof b === "string") {
      return a.concat(b); // 字符串拼接
    }
  }
  throw new Error("参数类型或数量不匹配");
}

console.log(process(5));         // 25
console.log(process("hello"));   // "HELLO"
console.log(process(10, 20));    // 30
console.log(process("a", "b"));  // "ab"
```

##### 2. 使用函数属性

可以将不同的实现作为主函数的属性：

```js
function format(text) {
  // 默认实现
  return text.toString();
}

// 添加特定实现
format.number = function(num) {
  return num.toFixed(2);
};

format.date = function(date) {
  return `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}`;
};

format.array = function(arr) {
  return arr.join(", ");
};

// 使用
console.log(format(123));                 // "123"
console.log(format.number(123.456));      // "123.46"
console.log(format.date(new Date()));     // "2023-11-10"
console.log(format.array([1, 2, 3]));     // "1, 2, 3"
```

##### 3. 闭包实现（参数签名映射）

这是一种更灵活的方法，可以根据参数类型创建函数映射表：

```js
function createOverload() {
  const map = new Map();
  function overload(...args) {
    const types = args.map((arg) => typeof arg).join(",");
    if (map.has(types)) {
      const fn = map.get(types);
      return fn.apply(this, args);
    } else {
      throw new Error("函数不存在");
    }
  }
  overload.addImpl = (...args) => {
    const keys = args.slice(0, -1).join(",");
    const fn = args[args.length - 1];
    if (map.get(keys)) {
      throw new Error("函数已存在");
    }
    map.set(keys, fn);
  };
  return overload;
}

const overload = createOverload();
overload.addImpl("number", "number", (a, b) => {
  return a + b;
});
overload.addImpl("string", "string", (a, b) => {
  return a.concat(b);
});
overload.addImpl("number", "number", "number", (a, b, c) => {
  return a + b + c;
});

console.log(overload(1, 2));           // 3
console.log(overload("hello", " world"));  // "hello world"
console.log(overload(1, 2, 3));        // 6
```

##### 4. 改进版: 支持更复杂的参数匹配

可以进一步改进，支持更复杂的参数匹配逻辑：

```js
function createOverload() {
  const implementations = [];
  
  function overload(...args) {
    // 查找匹配的实现
    for (const impl of implementations) {
      if (impl.matcher(args)) {
        return impl.fn.apply(this, args);
      }
    }
    throw new Error("没有找到匹配的函数实现");
  }
  
  // 添加基于类型的实现
  overload.addTypeImpl = function(...args) {
    const types = args.slice(0, -1);
    const fn = args[args.length - 1];
    
    // 创建匹配器函数
    const matcher = (fnArgs) => {
      if (fnArgs.length !== types.length) return false;
      
      // 检查每个参数的类型是否匹配
      for (let i = 0; i < types.length; i++) {
        if (typeof fnArgs[i] !== types[i]) return false;
      }
      return true;
    };
    
    implementations.push({ matcher, fn });
    return overload;
  };
  
  // 添加自定义匹配器的实现
  overload.addImpl = function(matcher, fn) {
    implementations.push({ matcher, fn });
    return overload;
  };
  
  return overload;
}

const calculate = createOverload();

// 添加不同类型的实现
calculate.addTypeImpl("number", (a) => a * a);
calculate.addTypeImpl("number", "number", (a, b) => a + b);
calculate.addTypeImpl("string", "string", (a, b) => `${a} ${b}`);

// 添加自定义匹配器
calculate.addImpl(
  args => Array.isArray(args[0]),
  arr => arr[0].reduce((sum, n) => sum + n, 0)
);

console.log(calculate(5));                // 25
console.log(calculate(10, 20));           // 30
console.log(calculate("hello", "world")); // "hello world"
console.log(calculate([1, 2, 3, 4]));     // 10
```

## 使用 TypeScript 实现真正的函数重载

在 TypeScript 中，我们可以实现真正的函数重载：

```typescript
// 声明函数重载
function process(value: number): number;
function process(value: string): string;
function process(value: boolean): boolean;
function process(value: any[]): number;

// 实现函数
function process(value: any): any {
  if (typeof value === "number") {
    return value * 2;
  } else if (typeof value === "string") {
    return value.toUpperCase();
  } else if (typeof value === "boolean") {
    return !value;
  } else if (Array.isArray(value)) {
    return value.length;
  }
}

// 使用
console.log(process(10));        // 20
console.log(process("hello"));   // "HELLO"
console.log(process(true));      // false
console.log(process([1, 2, 3])); // 3
```
