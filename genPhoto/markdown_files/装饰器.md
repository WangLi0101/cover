## 装饰器的基本概念

**装饰器** 是一种特殊的声明，能够被附加到类声明、方法、访问器、属性或参数上。装饰器使用 `@` 符号作为前缀，并紧接在目标声明之前。**装饰器本质上是一个函数，接收特定的参数，根据目标的不同类型（类、方法、属性等），参数和行为也有所不同。**

### 装饰器的类型

TypeScript 支持以下几种类型的装饰器：

1. **类装饰器（Class Decorators）**
2. **方法装饰器（Method Decorators）**
3. **访问器装饰器（Accessor Decorators）**
4. **属性装饰器（Property Decorators）**
5. **参数装饰器（Parameter Decorators）**

## 装饰器的作用

装饰器主要用于以下几个方面：

1. **元数据注入**：为类及其成员添加元数据，供运行时或其他工具使用。
2. **行为修改**：在不修改原有类或成员代码的情况下，增强或改变其行为。
3. **代码复用**：通过装饰器模式，复用通用的逻辑，如日志记录、权限验证等。
4. **依赖注入**：在依赖注入框架中，用于标识和管理依赖关系。

## TypeScript 中装饰器的使用

在 TypeScript 中使用装饰器，需要按照以下步骤进行：

1. **启用实验性装饰器**：装饰器是 TypeScript 的实验性特性，需要在 `tsconfig.json` 中启用。
2. **定义装饰器函数**：根据装饰器类型，定义相应的装饰器函数。
3. **应用装饰器**：使用 `@装饰器名称` 语法将装饰器应用到目标声明上。

### 装饰器函数的定义

装饰器函数根据目标的不同，接收不同的参数。以下是类装饰器的定义签名：

```typescript
function classDecorator<T extends { new (...args: any[]): {} }>(constructor: T) {
    // 修改或扩展类
    return class extends constructor {
        newProperty = "new property";
        hello = "override";
    };
}
```

## 类装饰器详解

**类装饰器** 是应用于类声明的装饰器。它在类声明被完全解析之后运行，并且可以通过装饰器函数修改或替换类的定义。

### 类装饰器的签名

类装饰器的函数签名如下：

```typescript
declare type ClassDecorator = <TFunction extends Function>(target: TFunction) => TFunction | void;
```

- 参数：

  - `target`：被装饰的类的构造函数。

- 返回值：

  - 可以返回一个新的构造函数来替换原有的类定义，也可以返回 `void` 来保持原有类不变。

### 使用场景

- **修改类的原型**：向类的原型添加新属性或方法。
- **替换类**：返回一个新的类来替换原有类，实现类的增强或修改。
- **注入元数据**：为类添加额外的元数据，供运行时或其他工具使用。

## 示例：使用类装饰器

下面通过一个实际的示例，展示如何在 TypeScript 中使用类装饰器。

### 示例 1：简单的类装饰器

```typescript
// 定义一个类装饰器，添加一个新属性
function addTimestamp<T extends { new (...args: any[]): {} }>(constructor: T) {
  return class extends constructor {
    timestamp = new Date();
  };
}

@addTimestamp
class User {
  name: string;

  constructor(name: string) {
    this.name = name;
  }

  sayHello() {
    console.log(`Hello, ${this.name}!`);
  }
}

const user = new User("Alice");
user.sayHello(); // 输出: Hello, Alice!
console.log((user as any).timestamp); // 输出: 当前日期和时间
```

**解释**：

1. **装饰器函数 `addTimestamp`**：
   - 接收被装饰类的构造函数 `constructor`。
   - 返回一个新的类，继承自原有类，并添加一个 `timestamp` 属性。
2. **应用装饰器 `@addTimestamp`**：
   - 将装饰器应用到 `User` 类上。
   - 创建 `User` 类的新实例时，实例将包含 `timestamp` 属性。

### 示例 2：替换类构造函数

```typescript
// 定义一个类装饰器，替换类的构造函数
function replaceConstructor<T extends { new (...args: any[]): {} }>(constructor: T) {
    return class extends constructor {
        name = "Replaced Name";
    };
}

@replaceConstructor
class Product {
    name: string;

    constructor(name: string) {
        this.name = name;
    }

    display() {
        console.log(`Product Name: ${this.name}`);
    }
}

const product = new Product("Original Name");
product.display(); // 输出: Product Name: Replaced Name
```

**解释**：

1. **装饰器函数 `replaceConstructor`**：
   - 接收被装饰类的构造函数 `constructor`。
   - 返回一个新的类，继承自原有类，并将 `name` 属性替换为 `"Replaced Name"`。
2. **应用装饰器 `@replaceConstructor`**：
   - 将装饰器应用到 `Product` 类上。
   - 创建 `Product` 类的新实例时，`name` 属性被替换。

### 示例 3：添加方法到类

```typescript
function addGreetMethod<T extends { new (...args: any[]): {} }>(
  constructor: T
) {
  return class extends constructor {
    greet() {
      console.log(`Greetings from ${(this as any).name}!`);
    }
  };
}

@addGreetMethod
class Developer {
  name: string;

  constructor(name: string) {
    this.name = name;
  }

  code() {
    console.log(`${this.name} is coding.`);
  }
}

const dev = new Developer("Bob");
dev.code(); // 输出: Bob is coding.
(dev as any).greet(); // 输出: Greetings from Bob!
```

**注意**：在此示例中，装饰器添加了 `greet` 方法，但 TypeScript 并不知道 `Developer` 类现在拥有 `greet` 方法。因此，需要使用类型断言（`as any`）来调用 `greet` 方法，或者更好的做法是通过接口或类型声明来扩展类的类型。

### 示例 4：使用接口扩展装饰器增强的类

```typescript
interface Greetable {
  greet(): void;
}

function addGreetMethod<T extends { new (...args: any[]): {} }>(
  constructor: T
) {
  return class extends constructor implements Greetable {
    greet() {
      console.log(`Greetings from ${(this as any).name}!`);
    }
  };
}

@addGreetMethod
class Developer {
  name: string;

  constructor(name: string) {
    this.name = name;
  }

  code() {
    console.log(`${this.name} is coding.`);
  }
}

const dev = new Developer("Bob");
dev.code(); // 输出: Bob is coding.
(dev as any).greet(); // 输出: Greetings from Bob!
```

**解释**：

1. **接口 `Greetable`**：
   - 定义了 `greet` 方法的签名。
2. **装饰器函数 `addGreetMethod`**：
   - 返回一个新类，继承自原有类，并实现 `Greetable` 接口。
   - 添加了 `greet` 方法。
3. **应用装饰器 `@addGreetMethod`**：
   - `Developer` 类现在实现了 `Greetable` 接口，拥有 `greet` 方法。

## 启用装饰器

装饰器是 TypeScript 的实验性特性，需要在 `tsconfig.json` 中启用相关配置：

```json
{
  "compilerOptions": {
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true, // 可选：用于生成元数据
    // 其他配置项...
  }
}
```

- **`experimentalDecorators`**：启用装饰器功能。
- **`emitDecoratorMetadata`**：启用装饰器元数据的生成（通常与依赖注入框架一起使用，如 Angular）。
## 方法装饰器（Method Decorators）

**方法装饰器** 是应用于类方法的装饰器。它可以用来修改方法的行为、添加元数据或进行其他操作。

### 方法装饰器的签名

方法装饰器的函数签名如下：

```typescript
declare type MethodDecorator = <T>(
    target: Object,
    propertyKey: string | symbol,
    descriptor: TypedPropertyDescriptor<T>
) => TypedPropertyDescriptor<T> | void;
```

- **参数**：
  - `target`：方法所属的类的原型对象（对于静态方法是构造函数）。
  - `propertyKey`：方法的名称。
  - `descriptor`：方法的属性描述符。
- **返回值**：
  - 可以返回一个新的属性描述符来修改方法，或者返回 `void` 保持原方法不变。

### 示例 1：日志记录装饰器

```typescript
// 定义一个方法装饰器，记录方法的调用
function logMethod(
    target: Object,
    propertyKey: string | symbol,
    descriptor: PropertyDescriptor
) {
    const originalMethod = descriptor.value;

    descriptor.value = function (...args: any[]) {
        console.log(`Method ${String(propertyKey)} called with arguments:`, args);
        const result = originalMethod.apply(this, args);
        console.log(`Method ${String(propertyKey)} returned:`, result);
        return result;
    };

    return descriptor;
}

class Calculator {
    @logMethod
    add(a: number, b: number): number {
        return a + b;
    }

    @logMethod
    multiply(a: number, b: number): number {
        return a * b;
    }
}

const calc = new Calculator();
calc.add(2, 3);
// 输出:
// Method add called with arguments: [ 2, 3 ]
// Method add returned: 5

calc.multiply(4, 5);
// 输出:
// Method multiply called with arguments: [ 4, 5 ]
// Method multiply returned: 20
```

**解释**：

1. **装饰器函数 `logMethod`**：
   - 保存原始方法 `originalMethod`。
   - 修改方法的 `descriptor.value`，在调用原方法前后添加日志输出。
   - 返回修改后的 `descriptor`。
2. **应用装饰器 `@logMethod`**：
   - 将装饰器应用到 `Calculator` 类的 `add` 和 `multiply` 方法上。
   - 调用这些方法时，会自动输出日志信息。

### 示例 2：方法缓存装饰器

```typescript
// 定义一个方法装饰器，缓存方法的返回值
function cacheMethod(
  target: Object,
  propertyKey: string | symbol,
  descriptor: PropertyDescriptor
) {
  const originalMethod = descriptor.value;
  const cache = new Map<string, any>();

  descriptor.value = function (...args: any[]) {
    const key = JSON.stringify(args);
    if (cache.has(key)) {
      console.log(`Returning cached result for ${String(propertyKey)}(${key})`);
      return cache.get(key);
    }
    const result = originalMethod.apply(this, args);
    cache.set(key, result);
    return result;
  };

  return descriptor;
}

class Fibonacci {
  @cacheMethod
  compute(n: number): number {
    if (n <= 1) return n;
    return this.compute(n - 1) + this.compute(n - 2);
  }
}

const fib = new Fibonacci();
console.log(fib.compute(5));
// 输出:
// Returning cached result for compute([1])
// Returning cached result for compute([2])
// Returning cached result for compute([3])
// 5
```

**解释**：

1. **装饰器函数 `cacheMethod`**：
   - 创建一个 `Map` 用于缓存方法的返回值。
   - 在方法调用时，检查参数是否已缓存，若有则返回缓存值；否则调用原方法并缓存结果。
2. **应用装饰器 `@cacheMethod`**：
   - 将装饰器应用到 `Fibonacci` 类的 `compute` 方法上。
   - 调用 `compute` 方法时，重复计算的结果将从缓存中获取，提升性能。

## 访问器装饰器（Accessor Decorators）

**访问器装饰器** 是应用于类的访问器（getter 或 setter）的方法。它可以用来修改访问器的行为、添加元数据或进行其他操作。

### 访问器装饰器的签名

访问器装饰器的函数签名如下：

```typescript
declare type AccessorDecorator = <T>(
    target: Object,
    propertyKey: string | symbol,
    descriptor: TypedPropertyDescriptor<T>
) => TypedPropertyDescriptor<T> | void;
```

- **参数**：
  - `target`：访问器所属的类的原型对象（对于静态访问器是构造函数）。
  - `propertyKey`：访问器的名称。
  - `descriptor`：访问器的属性描述符。
- **返回值**：
  - 可以返回一个新的属性描述符来修改访问器，或者返回 `void` 保持原访问器不变。

### 示例 1：访问器日志记录装饰器

```typescript
// 定义一个访问器装饰器，记录访问器的调用
function logAccessor(
    target: Object,
    propertyKey: string | symbol,
    descriptor: PropertyDescriptor
) {
    const originalGet = descriptor.get;
    const originalSet = descriptor.set;

    if (originalGet) {
        descriptor.get = function () {
            console.log(`Getter for ${String(propertyKey)} called`);
            return originalGet.apply(this);
        };
    }

    if (originalSet) {
        descriptor.set = function (value: any) {
            console.log(`Setter for ${String(propertyKey)} called with value:`, value);
            originalSet.apply(this, [value]);
        };
    }

    return descriptor;
}

class Person {
    private _age: number = 0;

    @logAccessor
    get age(): number {
        return this._age;
    }

    set age(value: number) {
        if (value < 0) {
            throw new Error("Age cannot be negative");
        }
        this._age = value;
    }
}

const person = new Person();
person.age = 30;
// 输出: Setter for age called with value: 30

console.log(person.age);
// 输出:
// Getter for age called
// 30
```

**解释**：

1. **装饰器函数 `logAccessor`**：
   - 保存原始的 getter 和 setter 方法。
   - 修改 getter 和 setter，添加日志输出。
2. **应用装饰器 `@logAccessor`**：
   - 将装饰器应用到 `Person` 类的 `age` 访问器上。
   - 调用 getter 和 setter 时，会自动输出日志信息。

### 示例 2：访问器验证装饰器

```typescript
// 定义一个访问器装饰器，验证赋值的值
function validateAccessor(
    target: Object,
    propertyKey: string | symbol,
    descriptor: PropertyDescriptor
) {
    const originalSet = descriptor.set;

    descriptor.set = function (value: any) {
        if (typeof value !== "number" || value < 0) {
            throw new Error(`Invalid value for ${String(propertyKey)}: ${value}`);
        }
        originalSet?.apply(this, [value]);
    };

    return descriptor;
}

class BankAccount {
    private _balance: number = 0;

    @validateAccessor
    get balance(): number {
        return this._balance;
    }

    set balance(value: number) {
        this._balance = value;
    }
}

const account = new BankAccount();
account.balance = 100;
console.log(account.balance); // 输出: 100

account.balance = -50; // 抛出错误: Invalid value for balance: -50
```

**解释**：

1. **装饰器函数 `validateAccessor`**：
   - 修改 setter 方法，添加值的类型和范围验证。
   - 若赋值不符合条件，则抛出错误。
2. **应用装饰器 `@validateAccessor`**：
   - 将装饰器应用到 `BankAccount` 类的 `balance` 访问器上。
   - 赋值操作将受到验证，确保数据的有效性。

## 属性装饰器（Property Decorators）

**属性装饰器** 是应用于类的属性的装饰器。它可以用来修改属性的行为、添加元数据或进行其他操作。

### 属性装饰器的签名

属性装饰器的函数签名如下：

```typescript
declare type PropertyDecorator = (target: Object, propertyKey: string | symbol) => void;
```

- **参数**：
  - `target`：属性所属的类的原型对象（对于静态属性是构造函数）。
  - `propertyKey`：属性的名称。
- **返回值**：
  - 属性装饰器通常不返回任何内容。

### 示例 1：属性日志记录装饰器

```typescript
// 定义一个属性装饰器，记录属性的访问
function logProperty(target: Object, propertyKey: string | symbol) {
    let value: any;

    const getter = function () {
        console.log(`Getting value of ${String(propertyKey)}:`, value);
        return value;
    };

    const setter = function (newVal: any) {
        console.log(`Setting value of ${String(propertyKey)} to:`, newVal);
        value = newVal;
    };

    Object.defineProperty(target, propertyKey, {
        get: getter,
        set: setter,
        enumerable: true,
        configurable: true,
    });
}

class User {
    @logProperty
    public name: string;

    constructor(name: string) {
        this.name = name;
    }
}

const user = new User("Charlie");
// 输出: Setting value of name to: Charlie

console.log(user.name);
// 输出:
// Getting value of name: Charlie
// Charlie

user.name = "Dave";
// 输出: Setting value of name to: Dave

console.log(user.name);
// 输出:
// Getting value of name: Dave
// Dave
```

**解释**：

1. **装饰器函数 `logProperty`**：
   - 定义属性的 getter 和 setter，添加日志输出。
   - 使用 `Object.defineProperty` 替换原有属性描述符。
2. **应用装饰器 `@logProperty`**：
   - 将装饰器应用到 `User` 类的 `name` 属性上。
   - 访问和赋值操作将自动输出日志信息。

### 示例 2：属性默认值装饰器

```javascript
// 定义一个属性装饰器，设置属性的默认值
function defaultValue(defaultVal: any) {
    return function (target: Object, propertyKey: string | symbol) {
        let value = defaultVal;

        const getter = function () {
            return value;
        };

        const setter = function (newVal: any) {
            value = newVal;
        };

        Object.defineProperty(target, propertyKey, {
            get: getter,
            set: setter,
            enumerable: true,
            configurable: true,
        });
    };
}

class Config {
    @defaultValue("localhost")
    public host: string;

    @defaultValue(8080)
    public port: number;
}

const config = new Config();
console.log(config.host); // 输出: localhost
console.log(config.port); // 输出: 8080

config.host = "example.com";
config.port = 3000;

console.log(config.host); // 输出: example.com
console.log(config.port); // 输出: 3000
```

**解释**：

1. **装饰器函数 `defaultValue`**：
   - 接收一个默认值参数 `defaultVal`。
   - 定义属性的 getter 和 setter，初始化为默认值。
2. **应用装饰器 `@defaultValue`**：
   - 将装饰器应用到 `Config` 类的 `host` 和 `port` 属性上。
   - 属性在实例化时具有预设的默认值。

## 参数装饰器（Parameter Decorators）

**参数装饰器** 是应用于类方法参数的装饰器。它可以用来添加元数据、验证参数或进行其他操作。

### 参数装饰器的签名

参数装饰器的函数签名如下：

```typescript
declare type ParameterDecorator = (
    target: Object,
    propertyKey: string | symbol,
    parameterIndex: number
) => void;
```

- **参数**：
  - `target`：方法所属的类的原型对象（对于静态方法是构造函数）。
  - `propertyKey`：方法的名称。
  - `parameterIndex`：参数在方法参数列表中的索引。
- **返回值**：
  - 参数装饰器通常不返回任何内容。

### 示例 1：参数验证装饰器

```typescript
// 定义一个参数装饰器，标记参数为必需
function required(target: Object, propertyKey: string | symbol, parameterIndex: number) {
    const existingRequiredParameters: number[] = Reflect.getOwnMetadata("required", target, propertyKey) || [];
    existingRequiredParameters.push(parameterIndex);
    Reflect.defineMetadata("required", existingRequiredParameters, target, propertyKey);
}

import "reflect-metadata";

class UserService {
    createUser(name: string, @required email: string) {
        console.log(`Creating user: ${name}, Email: ${email}`);
    }
}

function validate(target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const method = descriptor.value;
    descriptor.value = function (...args: any[]) {
        const requiredParameters: number[] = Reflect.getOwnMetadata("required", target, propertyName) || [];
        for (const parameterIndex of requiredParameters) {
            if (args[parameterIndex] === undefined) {
                throw new Error(`Missing required argument at position ${parameterIndex} for method ${propertyName}`);
            }
        }
        return method.apply(this, args);
    };
}

class ValidatedUserService extends UserService {
    @validate
    createUser(name: string, email: string) {
        super.createUser(name, email);
    }
}

const service = new ValidatedUserService();
service.createUser("Eve", "eve@example.com"); // 正常执行
service.createUser("Frank"); // 抛出错误: Missing required argument at position 1 for method createUser
```

**解释**：

1. **装饰器函数 `required`**：
   - 标记方法参数为必需。
   - 使用 `Reflect` API 存储元数据，记录必需参数的索引。
2. **装饰器函数 `validate`**：
   - 在方法执行前，检查必需参数是否存在。
   - 如果缺少必需参数，抛出错误。
3. **应用装饰器 `@required`**：
   - 将装饰器应用到 `UserService` 类的 `createUser` 方法的 `email` 参数上。
4. **应用装饰器 `@validate`**：
   - 将装饰器应用到 `ValidatedUserService` 类的 `createUser` 方法上，用于执行参数验证。

### 示例 2：记录参数装饰器

```typescript
// 定义一个参数装饰器，记录参数的元数据
function logParameter(target: Object, propertyKey: string | symbol, parameterIndex: number) {
    const existingLoggedParameters: number[] = Reflect.getOwnMetadata("log_parameters", target, propertyKey) || [];
    existingLoggedParameters.push(parameterIndex);
    Reflect.defineMetadata("log_parameters", existingLoggedParameters, target, propertyKey);
}

import "reflect-metadata";

class MathService {
    sum(@logParameter a: number, @logParameter b: number): number {
        return a + b;
    }
}

function logMethod(target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const method = descriptor.value;
    descriptor.value = function (...args: any[]) {
        const loggedParameters: number[] = Reflect.getOwnMetadata("log_parameters", target, propertyName) || [];
        for (const index of loggedParameters) {
            console.log(`Parameter at index ${index}: ${args[index]}`);
        }
        return method.apply(this, args);
    };
}

class LoggedMathService extends MathService {
    @logMethod
    sum(a: number, b: number): number {
        return super.sum(a, b);
    }
}

const math = new LoggedMathService();
console.log(math.sum(5, 10));
// 输出:
// Parameter at index 0: 5
// Parameter at index 1: 10
// 15
```

**解释**：

1. **装饰器函数 `logParameter`**：
   - 标记方法参数，并记录其索引。
2. **装饰器函数 `logMethod`**：
   - 在方法执行前，输出标记参数的值。
3. **应用装饰器 `@logParameter`**：
   - 将装饰器应用到 `MathService` 类的 `sum` 方法的 `a` 和 `b` 参数上。
4. **应用装饰器 `@logMethod`**：
   - 将装饰器应用到 `LoggedMathService` 类的 `sum` 方法上，用于记录参数值。