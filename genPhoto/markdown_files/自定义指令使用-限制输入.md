### 需求场景
专员A:为什么这个地方输入的价格可以输入负数？

专员B：为啥这个地方可以出入0.5次？

专员C:为啥这里的价格能输入一位小数哪里的就不行？

我：哪儿特么来这么多为什么？

暴躁归暴躁，问题还是得想办法解决，于是乎就有了以下对话：

我：........，既然人家技术专员提出来了，咱就得想办法解决统一一下啊。

技术A:咱现在不都有用正则限制嘛？

我：正则的话每个地方的限制规则也不一样，而且每个页面都写太麻烦了，有啥好办法嘛？

技术B:写成全局的不就可以了！（虽然觉得在抬杠，但貌似也没啥问题）

我：......，那不还得每个页面都引入嘛！

OK，闲扯到这里正式结束，正题马上开始！

### 技术方案实现

本质上来讲，我们要想对input的输入的内容做限制，肯定是没法脱离正则的，但是每个页面都写确实不现实，而且现在项目运行了好几年了都，一个一个改肯定得疯几个开发人员。

灵机一动下，想到了vue提供的生态（自定义指令），一番思索下，这不就是我要的最佳方案嘛。

1. 首先要确认的就是数字的限制分类（这一步是很重要的，如果需求都理不清的话，后续后又很大的麻烦，我这里整理了五种分类，对于负数没有单独做处理）

  a. 全部合法数字类型

  b. 正整数

  c. 正数

  d. 整数

  e. 包含0的正整数（此情况单独处理）

2. 在存放自定义指令的文件中新建一个自定义指令

3. 手撸代码片段

  a. 当el-input设置type为number时，输入非数字指令监听不到，所以使用指令时type使用默认值即可。

  b. 针对输入法需要做特殊的处理，这里使用监听compositionstart、compositionend做了类似防抖的处理。

``` javascript
export const restrictToNumber = {
  bind(el, binding) {
    const type = binding.arg
    const targetNumber = binding.value ? parseFloat(binding.value) : null
    //输入完毕后，使用正则格式化内容
    function handleInput(event) {
      if (!el.__composing) {
        restrictInputToNumber(type, targetNumber, event)
      }
    }
    //输入法开始
    function handleCompositionStart() {
      el.__composing = true
    }
    //输入法结束
    function handleCompositionEnd(event) {
      el.__composing = false
      restrictInputToNumber(type, targetNumber, event)
    }
    //给节点绑定事件
    el.addEventListener('input', handleInput)
    el.addEventListener('compositionstart', handleCompositionStart)
    el.addEventListener('compositionend', handleCompositionEnd)
    //将事件名称绑定到节点上，为了后续移除事件
    el.__handleInput = handleInput
    el.__handleCompositionStart = handleCompositionStart
    el.__handleCompositionEnd = handleCompositionEnd
  },
  unbind(el) {
    //移除事件
    el.removeEventListener('input', el.__handleInput)
    el.removeEventListener('compositionstart', el.__handleCompositionStart)
    el.removeEventListener('compositionend', el.__handleCompositionEnd)
    //移除节点上绑定的方法
    delete el.__handleInput
    delete el.__handleCompositionStart
    delete el.__handleCompositionEnd
  }
}
```

4. 指令完成测试后，将其注册到全局自定义指令即可。

### 指令说明
● v-restrict-to-number:positive-integer：只允许输入正整数

● v-restrict-to-number:integer：只允许输入整数

● v-restrict-to-number:positive-number：只允许输入正数

● v-restrict-to-number：允许输入任意合法数字

● positive-integer-has-zero：允许输入正整数和0

### 完整代码

```javascript
export const restrictToNumber = {
  bind(el, binding) {
    const type = binding.arg
    const targetNumber = binding.value ? parseFloat(binding.value) : null
    function handleInput(event) {
      if (!el.__composing) {
        restrictInputToNumber(type, targetNumber, event)
      }
    }

    function handleCompositionStart() {
      el.__composing = true
    }

    function handleCompositionEnd(event) {
      el.__composing = false
      restrictInputToNumber(type, targetNumber, event)
    }

    el.addEventListener('input', handleInput)
    el.addEventListener('compositionstart', handleCompositionStart)
    el.addEventListener('compositionend', handleCompositionEnd)

    el.__handleInput = handleInput
    el.__handleCompositionStart = handleCompositionStart
    el.__handleCompositionEnd = handleCompositionEnd
  },
  unbind(el) {
    el.removeEventListener('input', el.__handleInput)
    el.removeEventListener('compositionstart', el.__handleCompositionStart)
    el.removeEventListener('compositionend', el.__handleCompositionEnd)
    delete el.__handleInput
    delete el.__handleCompositionStart
    delete el.__handleCompositionEnd
  }
}
function restrictInputToNumber(type, targetNumber, event) {
  const input = event.target
  let value = input.value || ''
  let dotIndex = ''
  let hasDot = false
  // 根据限制类型执行相应的逻辑
  switch (type) {
    case 'positive-integer-has-zero': // 支持正整数和0
      if (value != '0') {
        value = value.replace(/[a-zA-Z]/g, '')
        value = value.replace(/\D/g, '') // 正整数，移除非数字字符
        value = value.replace(/^0+/, '') // 移除前导零
        value = value.replace(/[^0-9]/g, '') // 移除非法字符

        // 限制多个小数点和多个符号
        value = value.replace(/\./g, (match, offset) => {
          return offset === 0 ? '.' : ''
        })
        value = value.replace(/-/g, (match, offset) => {
          return offset === 0 ? '-' : ''
        })
      }
      break
    case 'positive-integer':
      value = value.replace(/[a-zA-Z]/g, '')
      value = value.replace(/\D/g, '') // 正整数，移除非数字字符
      value = value.replace(/^0+/, '') // 移除前导零
      value = value.replace(/[^0-9]/g, '') // 移除非法字符

      // 限制多个小数点和多个符号
      value = value.replace(/\./g, (match, offset) => {
        return offset === 0 ? '.' : ''
      })
      value = value.replace(/-/g, (match, offset) => {
        return offset === 0 ? '-' : ''
      })
      break
    case 'integer':
      value = value.replace(/[a-zA-Z]/g, '')
      value = value.replace(/[^-0-9]/g, '') // 整数，移除非数字和负号字符
      // 限制多个小数点和多个符号
      value = value.replace(/\./g, (match, offset) => {
        return offset === 0 ? '.' : ''
      })
      value = value.replace(/-/g, (match, offset) => {
        return offset === 0 ? '-' : ''
      })
      break
    case 'positive-number':
      value = value.replace(/[a-zA-Z]/g, '')
      value = value.replace(/[^\d.]/g, '') // 正数，移除非数字和小数点字符
      value = value.replace(/^\./g, '') // 移除前导小数点
      value = value.replace(/\.{2,}/g, '.') // 多个小数点合并为一个
      value = value.replace(/^0(\d+)/, '$1') // 移除前导零

      // 限制多个符号
      hasDot = false // 用于标记是否已经出现过小数点
      value = value.replace(/-/g, (match, offset) => {
        if (offset === 0) {
          return match
        } else {
          return ''
        }
      }).replace(/\./g, (match) => {
        if (!hasDot) {
          hasDot = true
          return match
        } else {
          return ''
        }
      })

      // 限制小数点最多两位
      dotIndex = value.indexOf('.')
      if (dotIndex !== -1) {
        const decimalPart = value.substr(dotIndex + 1)
        if (decimalPart.length > 2) {
          value = value.slice(0, dotIndex + 3)
        }
      }

      break
    default:
      value = value.replace(/[a-zA-Z]/g, '')
      value = value.replace(/[^-?\d.]/g, '')
      // 移除多个符号和多个小数点
      value = value.replace(/([-.])(?=.*\1)/g, '')
      break
  }
  if (value !== input.value) {
    // 检查新值是否与旧值不同
    input.value = value
    input.dispatchEvent(new Event('input'))
  }

  if (targetNumber !== null) {
    const numericValue = parseFloat(value)
    if (!isNaN(numericValue) && numericValue > targetNumber) {
      console.log(`The input number ${numericValue} is greater than ${targetNumber}.`)
      if (input.value !== targetNumber.toString()) {
        input.value = targetNumber
        input.dispatchEvent(new Event('input'))
      }
    }
  }

 
}
```