### 代码输出

#### 代码

```javascript
const obj = {
  a: 3,
  b: 4,
  c: null,
  d: undefined,
  get e() {
    return 111;
  },
  get f() {},
};

console.log(JSON.stringify(obj));
```

#### 代码输出结果

```json
{ "a": 3, "b": 4, "c": null, "e": 111 }
```

#### 解释

- `d` 和 `f` 两个属性被忽略，因为它们的值是 `undefined` 和 `undefined`。
- `e` 和 `f` 是 getter，使用 `JSON.stringify` 时会调用 getter，所以 `e` 返回 `111`， 而 `f` 返回 `undefined`，所以 `f` 也被忽略。

#### 代码

```javascript
console.log(Array(100).map((x) => 1));
```

#### 代码输出结果

```json
[ <100 empty items> ]
```

#### 解释

- `Array(100)` 将会创建一个稀疏数组 (`sparse array`)，即不存在真实元素，节省内存空间。在控制台上显示为 `[empty]`
- 正因为没有元素，所以它也不会有 `map` 操作，所以 `Array(100).map(x => 1)` 仍然返回为 `[empty]`

#### 扩展

- 如果想要创建一个长度为 100 的数组，并且每个元素都是 `1`，可以使用以下方法：

```javascript
Array.from(Array(100), (x) => 1);
// Array.apply(null, Array(100)) 相当于调用 Array 构造函数，
// 并且给它提供了 100 个未定义的参数，这样会生成一个具有 100 个 undefined 元素的数组。
Array.apply(null, Array(100)).map((x) => 1);
Array(100).fill(1);
```

#### 代码

```javascript
setTimeout(() => console.log(0));
new Promise((resolve) => {
  console.log(1);
  resolve(2);
  console.log(3);
}).then((o) => console.log(o));

new Promise((resolve) => {
  console.log(4);
  resolve(5);
})
  .then((o) => console.log(o))
  .then(() => console.log(6));
```

#### 代码输出结果

```bash
1 3 4 2 5 6 0
```

#### 解释

- 首先执行同步代码：输出 1，3，4。
- 接着执行微任务队列：输出 2，5，6。
- 最后执行宏任务：输出 0（来自 setTimeout）。

#### 代码

```javascript
setTimeout(() => {
  console.log("A");
  Promise.resolve().then(() => {
    console.log("B");
  });
}, 1000);

Promise.resolve().then(() => {
  console.log("C");
});

new Promise((resolve) => {
  console.log("D");
  resolve("");
}).then(() => {
  console.log("E");
});

async function sum(a, b) {
  console.log("F");
}

async function asyncSum(a, b) {
  await Promise.resolve();
  console.log("G");
  return Promise.resolve(a + b);
}

sum(3, 4);
asyncSum(3, 4);
console.log("H");
```

#### 代码输出结果

```mathematica
D
F
H
C
E
G
A
B
```

#### 解释：

1. **同步代码部分**：

   - `console.log("D")` 是在创建 `new Promise` 时同步执行的，所以它是第一个输出。
   - `sum(3, 4)` 是一个普通的 `async` 函数，它在调用时不会等待 `await`，所以 `console.log("F")` 紧接着输出。
   - `console.log("H")` 是同步代码，也立即执行。

   因此，首先输出的是：

   ```mathematica
   D
   F
   H
   ```

2. **`Promise` 微任务部分**：

   - `Promise.resolve().then(() => console.log("C"))` 是微任务，会在当前同步代码结束后立即执行。
   - `new Promise(...).then(() => console.log("E"))` 同样是微任务，会在同步代码结束后执行。
   - `asyncSum(3, 4)` 中的 `await Promise.resolve()` 会将 `console.log("G")` 推入微任务队列，晚于前两个微任务执行。

   微任务依次执行，输出：

   ```mathematica
   C
   E
   G
   ```

3. **`setTimeout` 宏任务部分**：

   - `setTimeout` 定时器中的回调函数是宏任务，只有在所有同步代码和微任务完成后才会执行。先输出 `"A"`，随后 `Promise.resolve().then(() => console.log("B"))` 是回调中的微任务，紧接着输出 `"B"`。

   宏任务执行后输出：

   ```mathematica
   A
   B
   ```

#### 代码

```javascript
for (var i = 0; i < 5; i++) {
  setTimeout(() => console.log(i), 1000);
}
```

#### 代码输出结果

```bash
# 1s 后输出 5 5 5 5 5
5 5 5 5 5
```

#### 解释

- `for` 循环中的 `var` 变量 `i` 是全局变量，因此在 `setTimeout` 的回调中访问的是同一个全局变量 `i`。
- 当 `setTimeout` 在 1 秒后执行时，循环已经完成，`i` 的值为 5。
- 因此，所有回调函数访问的 `i` 都是 5。

如果想要输出 0 1 2 3 4

- 可以使用 `let` 代替 `var`，因为 `let` 是块级作用域，每次循环都会创建一个新的块级作用域，从而保证每个回调函数访问的 `i` 都是不同的。

```javascript
for (let i = 0; i < 5; i++) {
  setTimeout(() => console.log(i), 1000);
}
```

- 可以使用 `IIFE` 立即执行函数表达式，每次循环都会创建一个新的函数作用域，从而保证每个回调函数访问的 `i` 都是不同的。

```javascript
for (var i = 0; i < 5; i++) {
  (function (i) {
    setTimeout(() => console.log(i), 1000);
  })(i);
}
```

#### 代码

```javascript
"use strict";
function foo() {
  console.log(this);
}

foo.call(3);
```

#### 代码输出结果

```bash
3
```

#### 解释

- `foo.call(3)` 中的 `call` 方法将 `foo` 函数的 `this` 指向 `3`，所以 `console.log(this)` 输出 `3`。

> 但是，如果在非严格模式下，输出的是 `[Number: 3]`, 因为非严格模式下，基本类型会被转化成它的包装对象，所以 `this` 指向的是 `Number` 对象。

#### 代码

```javascript
console.log(Boolean(new Boolean(false)));
console.log(Boolean(document.all));
console.log([] == "");
console.log([3] == 3);
console.log([] == false);
console.log(42 == true);
```

#### 代码输出结果

```bash
true
false
true
true
true
false
```

#### 解释

![state](https://libra-blog.oss-cn-beijing.aliyuncs.com/src/124141063-a5c7b400-dabb-11eb-8a8c-2f9503f9f06e.png)

- `Boolean(new Boolean(false))`

```javascript
// 当 Boolean 作为构造函数时，返回一个新的 Boolean 对象， 它不是一个原始值
// 当 Boolean 作为函数时，它会将参数转换为布尔值
new Boolean(false); // Boolean {false}
Boolean(new Boolean(false)); // true
```

- `Boolean(document.all)`

在现代浏览器中，`document.all` 是一个特殊的对象，它在布尔上下文中被认为是 `false`。这是因为 `document.all` 被设计为一个“虚值”（`falsy value`），尽管它在其他上下文中可以正常工作。这种行为的原因是为了兼容旧版的 Internet Explorer。在旧版 IE 中，`document.all` 是一个真值（`truthy value`），而在现代浏览器中，它被特意设计为一个虚值，以便开发者可以通过检查 `document.all` 来区分浏览器类型。

- `[] == ""`

```javascript
Array.prototype.toString.call([]); // ""
```

- `[3] == 3`

```javascript
Array.prototype.toString.call([3]); // "3"
Number("3"); // 3
```

- `[] == false`

```javascript
Array.prototype.toString.call([]); // ""
Number(false); // 0
Number(""); // 0
```

- `42 == true`

```javascript
Number(true); // 1
```

#### 代码

```javascript
var a = 3;
let a;
```

#### 代码输出结果

```bash
Uncaught SyntaxError: Identifier 'a' has already been declared
```

#### 解释

运行这段代码会导致一个语法错误（SyntaxError）。这是因为在同一个作用域中，不能使用 `let` 声明一个已经用 `var` 声明过的变量

#### 代码

```javascript
var x = 3;
function foo(x = x) {
  // ..
}
foo();
```

#### 代码输出结果

```bash
Uncaught ReferenceError: Cannot access 'x' before initialization
```

#### 解释

在 `JavaScript` 中，当函数有一个默认参数值时，它会在调用函数时创建一个新的作用域。这个新的作用域是在函数体和全局作用域之间的一种临时作用域，仅在解析默认参数值时存在。

在这个临时作用域中，如果引用了与默认参数同名的变量（在这个例子中是 `x`），那么这个引用会被解析为这个临时作用域中的变量，而不是全局作用域中的变量。

所以，`x = x` 实际上是试图将 `x` 等于他自身这个未被初始化的变量，然后由于在临时作用域中找不到 `x` 的值，这就引发了一个引用错误。

可以这样修改：

```javascript
var x = 3;
function foo(y = x) {
  // ..
}
foo();
```

#### 代码

```javascript
var scope = "global scope";
function checkScope() {
  var scope = "local scope";
  function f() {
    return scope;
  }
  return f;
}

checkScope()();
```

#### 代码输出结果

```bash
"local scope"
```

#### 解释

由于 `js` 为词法作用域(Lexical Scope)，访问某个变量时，先在当前作用域中查找，如果找不到，就向上级作用域查找，直到全局作用域。

#### 代码

```javascript
function foo() {
  console.log(this.a);
}
var a = 2;
(function () {
  "use strict";

  foo();
})();
```

#### 代码输出结果

```bash
2
```

#### 解释

**只有在存在 `this` 的函数中设置严格模式，`this` 为 `undefined`。**
可以理解为上面代码中的 `use strict` 没有作用， 如果加在最上方， 则 `this` 为 `undefined`

#### 代码

```javascript
function F() {
  this.a = 3;
  return {
    a: 4,
  };
}
const f = new F();
console.log(f.a);
```

#### 代码输出结果

```bash
4
```

#### 解释

`new` 操作符默认返回 `this`， 但是如果手动指定返回对象，则 new 出来的实例指向的是 return 的对象，而不是 `this`

#### 代码
```javascript
Promise.resolve(console.log(0))
  .then(() => {
    console.log(1);
    Promise.resolve(console.log(5))
      .then(() => console.log(3))
      .then(() => console.log(4))
      .then(() => console.log(6));
  })
  .then(() => console.log(2))
  .then(() => console.log(7));
```
#### 代码输出结果

```bash
0
1
5
3
2
4
7
6
```

#### 解释

- 首先， 修改一下代码如下

> 将 then 的回调函数命名为 F1, F2, F3, F4, F6, F7， 然后每个 then 的回调函数都返回 undefined

```javascript
Promise.resolve(console.log(0))
  .then(function F1() {
    console.log(1);
    Promise.resolve(console.log(5))
      .then(function F3() {
        console.log(3);
        return undefined;
      })
      .then(function F4() {
        console.log(4);
        return undefined;
      })
      .then(function F6() {
        console.log(6);
        return undefined;
      });

    return undefined;
  })
  .then(function F2() {
    console.log(2);
    return undefined;
  })
  .then(function F7() {
    console.log(7);
    return undefined;
  });
```

### 执行过程

- 打印 0, F1 放入 microtask
- 调用栈空了, 从 microtask 拿 F1 执行
- 打印 1, 遇到 Promise.resolve
- 打印 5, 遇到 then, F3 放入 microtask
- 继续执行同步的代码 也就是 return undefined, 然后看到 then
- 然后把 F2 放入 microtask
- 调用栈空了, 从 microtask 按顺序拿 F3 执行
- 打印 3, 再遇到 return undefined, 然后看到 then, 再把 F4 放入 microtask
- 从 microtask 按顺序拿 F2 执行
- 打印 2, 再遇到 return undefined, 然后看到 then, 再把 F7 放入 microtask
- 从 microtask 按顺序拿 F4 执行
- 打印 4, 再遇到 return undefined, 然后看到 then, 再把 F6 放入 microtask
- 从 microtask 按顺序拿 F7 执行
- 打印 7 再遇到 return undefined, 没有 then 了
- 从 microtask 按顺序拿 F6 执行
- 打印 6


#### 动画

![state](https://libra-blog.oss-cn-beijing.aliyuncs.com/src/call-stack-animation.gif)

#### 代码

```javascript
Promise.resolve()
  .then(() => {
    console.log(0);
    return Promise.resolve(4);
  })
  .then((res) => {
    console.log(res);
  });

Promise.resolve()
  .then(() => {
    console.log(1);
  })
  .then(() => {
    console.log(2);
  })
  .then(() => {
    console.log(3);
  })
  .then(() => {
    console.log(5);
  })
  .then(() => {
    console.log(6);
  });
```

#### 代码输出结果

```bash
0 1 2 3 4 5 6
```

#### 解释

在 v8 内部实现的 Promise 和标准的 Promise/A+ 规范存在差异。浏览器内部实现的区别。我们可以理解为，resolve 或者 return 遇到一个 Promise 对象时，得到这个 Promise 的值之后，会把这个值用微任务包装起来，在 return 值向外传递时，会产生第二个微任务。

所以代码

```javascript
new Promise((resolve) => {
  resolve(Promise.resolve(4));
}).then((res) => {
  console.log(res);
});
```

可以理解为

```javascript
new Promise((resolve) => {
  resolve(4);
})
  .then()
  .then()
  .then((res) => {
    console.log(res);
  });
```