> 以下代码中的滚动事件，可以使用节流函数进行优化。

```html
<!-- 多张图片 -->
<img src="" alt="" data-src="https://via.placeholder.com/300x350" />
```

### 方案一： 位置计算 + 滚动事件 (`Scroll`) + `DataSet API`

```javascript
window.onload = () => {
  Masonry();
};

window.onscroll = () => {
  Masonry();
};

function Masonry() {
  const imgs = document.querySelectorAll("img");
  imgs.forEach((img, index) => {
    if (img.offsetTop < window.innerHeight + window.scrollY) {
      img.src = img.getAttribute("data-src");
    }
  });
}
```

![state](https://libra-blog.oss-cn-beijing.aliyuncs.com/src/masonry01.png)

### 方案二：`getBoundingClientRect API` + `Scroll with Throttle` + `DataSet API`

> `getBoundingClientRect API` 可以获取元素的位置信息，包括元素的大小、位置等信息。这个位置信息是相对于视口的，也就是说，当元素在视口中时，`top` 为正值，当元素在视口之外时，`top` 为负值。

![state](https://libra-blog.oss-cn-beijing.aliyuncs.com/src/element-box-diagram.png)

```javascript
window.onload = () => {
  Masonry();
};

window.onscroll = () => {
  Masonry();
};

function Masonry() {
  const imgs = document.querySelectorAll("img");
  imgs.forEach((img, index) => {
    if (img.getBoundingClientRect().top < window.innerHeight) {
      img.src = img.getAttribute("data-src");
    }
  });
}
```

### 方案三：`IntersectionObserver API` + `DataSet API`

> `IntersectionObserver API` 可以判断元素是否进入视口，当元素进入视口时，会触发回调函数。

```javascript
window.onload = () => {
  Masonry();
};

function Masonry() {
  const imgs = document.querySelectorAll("img");
  const observer = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      // isIntersecting 表示元素是否进入视口
      if (entry.isIntersecting) {
        entry.target.src = entry.target.getAttribute("data-src");
      }
    });
  });

  imgs.forEach((img) => {
    observer.observe(img);
  });
}
```

### 方案四: `LazyLoading` 属性

> `LazyLoading` 属性是一个新的属性，可以实现图片的懒加载。但是测试这个懒加载行为并不是固定的，和屏幕高度，网速等因素有关。

```html
<img alt="" src="https://via.placeholder.com/300x350" loading="lazy" />
```
