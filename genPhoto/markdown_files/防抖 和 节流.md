### 定义

- 防抖： 防抖是指在一段时间内，不管触发多少次回调，都只执行最后一次。比如在搜索框中输入搜索内容，只有在输入完成后，再过一段时间再执行搜索操作。
- 节流： 节流是指在一段时间内，不管触发多少次回调，都只执行一次。比如在页面滚动中，只有在停止滚动后，再过一段时间再执行滚动操作。

### 实现

#### 防抖

```javascript
function debounce(fn, delay) {
  let timer = null;
  return function () {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => {
      fn.apply(this, arguments);
    }, delay);
  };
}
```

#### 节流

```javascript
function throttle(fn, delay) {
  let canRun = true;
  return function () {
    if (!canRun) return;
    canRun = false;
    setTimeout(() => {
      fn.apply(this, arguments);
      canRun = true;
    }, delay);
  };
}
```

#### 为什么使用 apply

> apply() 方法调用一个具有给定 this 值的函数，以及作为一个数组（或类似数组的对象）提供的参数。

如果不使用 apply，那么在调用 fn 的时候，fn 中的 this 就会指向 window，而不是调用 debounce 或 throttle 的对象。

```js
const obj = {
  name: "Alice",
  sayHello() {
    console.log(`Hello, ${this.name}!`);
  },
};

function debounce(fn, delay) {
  let timer = null;
  return function () {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => {
      fn(arguments); // 注意这里直接调用了 fn(arguments)
    }, delay);
  };
}

const debouncedSayHello = debounce(obj.sayHello, 1000);

debouncedSayHello();
```

> 在上面的代码中，当调用 debouncedSayHello() 的时候，实际上调用了 debounce(obj.sayHello, 1000)(arguments)，而不是 obj.sayHello(arguments)。因此，obj.sayHello 中的 this 就会指向 window，而不是 obj。

### 应用场景

#### 防抖

- 搜索框输入搜索, 只有在输入完成后，再过一段时间再执行搜索操作
- 窗口大小变化，只有在停止调整窗口大小后，再过一段时间再执行调整操作
- 按钮提交事件，只需点击一次，防止多次提交
- 拖拽事件，只需在停止拖拽后，再过一段时间再执行拖拽操作
- 滚动事件，只有在停止滚动后，再过一段时间再执行滚动操作

#### 节流

- 鼠标不断点击触发，`mousedown`(单位时间内只触发一次)
- 监听滚动事件，比如是否滑到底部自动加载更多，用 `throttle` 来判断
- 搜索框，搜索联想功能
- 计算鼠标移动的距离，`mousemove`
