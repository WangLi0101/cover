```javascript
// 可遍历类型
const arrType = '[object Array]';
const objType = '[object Object]';
const mapType = '[object Map]';
const setType = '[object Set]';
const argType = '[object Arguments]';
const nullObjType = '[object NullObject]'; // 自定义类型标识，用于 Object.create(null) 创建的对象


// 不可遍历
const boolType = '[object Boolean]';
const numType = '[object Number]';
const strType = '[object String]';
const dateType = '[object Date]';
const errType = '[object Error]';
const regexpType = '[object RegExp]';
const symbolType = '[object Symbol]';
const funType = '[object Function]';
const weakMapType = '[object WeakMap]';
const weakSetType = '[object WeakSet]';
const undefinedType = '[object Undefined]';

// 将可遍历类型做个集合
const traverseTypes = [arrType, objType, mapType, setType, argType];

const isObject = (obj) => {
  const type = typeof obj;
  // typeof null === 'object'
  return obj !== null && (type === 'object' || type === 'function');
};

const getObjectType = (obj) => {
  if (Object.getPrototypeOf(obj) === null) {
    return nullObjType;
  }
  return Object.prototype.toString.call(obj);
};

// 克隆正则
const cloneRegExp = (obj) => {
  const {
    source,
    flags,
    lastIndex
  } = obj;
  const obj_ = new RegExp(source, flags);
  obj_.lastIndex = lastIndex;
  return obj_;
}

// 拷贝不便于遍历的对象类型
const cloneOtherType = (obj, type) => {
  switch (type) {
    case boolType:
    case numType:
    case strType:
    case dateType:
      return new obj.constructor(obj.valueOf());
    case symbolType:
      return Symbol.prototype.valueOf.call(obj)
    case regexpType:
      return cloneRegExp(obj);
    case weakMapType:
    case weakSetType:
      throw new Error("WeakMap and WeakSet are not clonable");
    case funType:
    case undefinedType:
      return obj;
    case nullObjType: // 针对 Object.create(null) 的处理
      return Object.create(null);
  }
}

const deepClone = (obj, map = new Map()) => {
  // 如果不是对象直接返回
  if (!isObject(obj)) {
    return obj;
  };

  // 获取当前参数的对象类型
  const objType = getObjectType(obj);

  // 根据constructor找到原始构造器，创建初始化对象
  let obj_;
  if (traverseTypes.includes(objType)) {
    // 如果是可遍历类型，直接创建空对象
    obj_ = new obj.constructor();
  } else {
    // 若不是，则走额外的处理
    return cloneOtherType(obj, objType);
  }

  // 解决循环引用问题
  if (map.has(obj)) {
    return map.get(obj);
  };
  // 存储当前拷贝的对象，以及我们要返回的对象
  map.set(obj, obj_);

  // 拷贝Set
  if (objType === setType) {
    obj.forEach((val) => {
      obj_.add(deepClone(val, map));
    });
    return obj_;
  };

  // 拷贝Map
  if (objType === mapType) {
    obj.forEach((val, key) => {
      obj_.set(key, deepClone(val, map));
    });
    return obj_;
  };

  // 如果是数组或者对象
  for (let i in obj) {
    if (obj.hasOwnProperty(i)) {
      obj_[i] = deepClone(obj[i], map);
  	}
  };
  return obj_;
};

```

### 为什么`WeakMap`和`WeakSet`不能被复制

#### **键的弱引用**：

- `WeakMap` 和 `WeakSet` 中的键
  - 在 `WeakMap` 中，键必须是对象，并且这些键是“弱引用”的。这意味着，如果没有其他引用指向这些对象，垃圾回收器可以随时回收这些对象。这种设计避免了内存泄漏，因为一旦对象没有其他引用，就会被清理掉。
  - 在 `WeakSet` 中，值也是对象，并且同样是“弱引用”。
- 为什么这影响克隆？
  - 由于 `WeakMap` 和 `WeakSet` 的键或值都是弱引用，克隆它们会涉及复制这些弱引用。而在新克隆的 `WeakMap` 或 `WeakSet` 中，原始对象可能已经被垃圾回收，这使得克隆出来的对象无法可靠地保留原有的映射关系或集合成员。

>想象一下 `WeakMap` 是一个藏宝箱。你可以在里面放各种东西，但只有你知道它们的钥匙。这些钥匙就是 `WeakMap` 里的键，它们可以是任何对象，比如一个人物角色、一个网页元素或者一个数据结构。
>
>现在，如果这个藏宝箱是 `WeakMap`，它有个特殊的能力：如果钥匙被丢掉了，宝箱就会自动把对应的东西扔掉，即使你还在里面放着它们。这就是 `WeakMap` 的弱引用特性，它不会死死地抓住键，而是依赖于你是否还在使用它们。
>
>所以，如果你想复制这个藏宝箱，你只能复制里面的钥匙，而不能复制里面的东西。因为如果钥匙被丢掉了，那些东西也会被扔掉，复制出来的藏宝箱就变得毫无意义了。

### 为什么 `Object.create(null)` 需要特殊处理

`Object.create(null)` 创建的对象没有原型链，也就是说它没有继承 `Object.prototype` 的任何方法或属性。

> `Object.create(null)` 创建的对象是一个纯净的对象，没有任何属性和方法。这种对象通常被用来存储数据，因为它不会受到原型链的干扰，也不会有任何属性名冲突。

### 关于`Symbol` 的克隆

为什么要使用 `Symbol.prototype.valueOf.call(obj)` 克隆 `Symbol` 类型，`Symbol` 是一种独特且不可变的数据类型，主要用于创建对象属性的唯一标识符。当我们需要深拷贝对象或其他复杂数据结构时，`Symbol` 类型的值也需要正确地被复制。但由于 `Symbol` 本身是一种原始类型，直接复制 `Symbol` 类型的变量将只拷贝它的引用，而不是创建一个新的 `Symbol`。

`Symbol.prototype.valueOf()` 是 `Symbol` 的原型方法，它返回的是 `Symbol` 对象的原始值。当你调用 `Symbol.prototype.valueOf.call(obj)` 时，你实际上是获取了 `obj` 的 `Symbol` 原始值。然后，你可以用这个原始值创建一个新的 `Symbol` 对象，这样就实现了 `Symbol` 类型的深拷贝。

### 关于`RegExp` 的克隆

- **`source`**: 正则表达式的主体部分，即正则表达式的内容。
  - 例如：`/abc/i` 中的 `abc`。
- **`flags`**: 正则表达式的标志，它们改变了正则表达式的行为。
  - 例如：`/abc/i` 中的 `i`，表示不区分大小写。
- **`lastIndex`**: 正则表达式对象的一个属性，表示下一次匹配应该从字符串的哪个位置开始。这个属性在你使用正则表达式对象进行多次匹配时非常重要，尤其是在全局（`g`）、粘性（`y`）标志的情况下。
  - 例如：在全局模式下（`/abc/g`），每次匹配后 `lastIndex` 会更新，指示下一次匹配从哪个字符开始。

#### **为什么需要手动克隆 `lastIndex`：**

如果你在克隆正则表达式时不考虑 `lastIndex`，那么在多次执行匹配操作时，新正则表达式将从头开始匹配，导致不同的结果。这在处理全局匹配或者粘性匹配时，可能会造成错误的行为。

#### **示例：**

```javascript
const regex = /foo/g;
const str = 'foo foo foo';

regex.test(str); // true, matches the first "foo"
console.log(regex.lastIndex); // 3, after first "foo"

regex.test(str); // true, matches the second "foo"
console.log(regex.lastIndex); // 7, after second "foo"

// 克隆正则表达式
const clonedRegex = new RegExp(regex.source, regex.flags);

// 如果不设置 lastIndex，克隆后的正则表达式会从头开始匹配
console.log(clonedRegex.lastIndex); // 0, by default
console.log(clonedRegex.test(str)); // true, matches the first "foo" again

// 设置 lastIndex
clonedRegex.lastIndex = regex.lastIndex;

console.log(clonedRegex.test(str)); // true, matches the third "foo"
console.log(clonedRegex.lastIndex); // 11, after third "foo"
```
