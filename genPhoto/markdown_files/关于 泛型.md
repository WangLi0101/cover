## 什么是泛型（Generics）

泛型是一种参数化类型的机制，允许在定义函数、类或接口时，不预先指定具体的类型，而是在使用时传入具体的类型。这样，泛型组件可以在不同的类型之间复用，同时保持类型安全。

## 如何创建泛型函数

创建泛型函数的基本语法是在函数名后使用尖括号 `<T>`（`T` 是一个常见的占位符，表示类型参数，可以是任意有效的标识符），然后在函数参数或返回类型中使用这个类型参数。

### 示例 1：简单的泛型函数

```typescript
// 定义一个泛型函数，返回传入的参数
function identity<T>(arg: T): T {
    return arg;
}

// 使用泛型函数时，可以显式指定类型
let result1 = identity<number>(42);
console.log(result1); // 输出: 42

// 也可以让 TypeScript 根据参数自动推断类型
let result2 = identity("Hello, 泛型!");
console.log(result2); // 输出: Hello, 泛型!
```

### 示例 2：多个类型参数

泛型函数还可以接受多个类型参数，以满足更复杂的需求。

```typescript
function merge<T, U>(obj1: T, obj2: U): T & U {
    return { ...obj1, ...obj2 };
}

const merged = merge({ name: "Alice" }, { age: 30 });
console.log(merged); // 输出: { name: "Alice", age: 30 }
```

## 如何创建泛型类

泛型不仅可以用于函数，还可以用于类和接口。泛型类允许类的某些成员保持泛型，从而使类在不同类型间复用。

### 示例 1：简单的泛型类

```typescript
// 定义一个泛型类，表示一个容器
class Container<T> {
    private value: T;

    constructor(value: T) {
        this.value = value;
    }

    getValue(): T {
        return this.value;
    }

    setValue(newValue: T): void {
        this.value = newValue;
    }
}

// 使用泛型类
const stringContainer = new Container<string>("Hello");
console.log(stringContainer.getValue()); // 输出: Hello

const numberContainer = new Container<number>(123);
console.log(numberContainer.getValue()); // 输出: 123

// 使用自定义类型
interface User {
    name: string;
    age: number;
}

const userContainer = new Container<User>({ name: "Bob", age: 25 });
console.log(userContainer.getValue()); // 输出: { name: "Bob", age: 25 }
```

### 示例 2：泛型类中的多个类型参数

```typescript
class Pair<K, V> {
    constructor(public key: K, public value: V) {}

    display(): void {
        console.log(`Key: ${this.key}, Value: ${this.value}`);
    }
}

const pair = new Pair<string, number>("age", 30);
pair.display(); // 输出: Key: age, Value: 30
```

## 泛型的实际用途

泛型在实际开发中有广泛的应用，以下是一些常见的用途：

### 1. 创建可复用的函数和类

通过泛型，可以编写与具体类型无关的通用函数和类，增强代码的复用性。例如，数组操作、数据结构等。

```typescript
// 泛型函数实现数组去重
function unique<T>(array: T[]): T[] {
    return Array.from(new Set(array));
}

const uniqueNumbers = unique<number>([1, 2, 2, 3, 4, 4]);
console.log(uniqueNumbers); // 输出: [1, 2, 3, 4]

const uniqueStrings = unique<string>(["a", "b", "a", "c"]);
console.log(uniqueStrings); // 输出: ["a", "b", "c"]
```

### 2. 与接口结合使用

泛型接口可以定义更灵活的接口结构，适用于多种类型。

```typescript
interface KeyValuePair<K, V> {
    key: K;
    value: V;
}

const pair1: KeyValuePair<string, number> = { key: "age", value: 30 };
const pair2: KeyValuePair<number, string> = { key: 1, value: "one" };
```

### 3. 提供类型约束

泛型可以通过 **约束（Constraints）** 来限制类型参数的范围，确保类型安全。

```typescript
// 约束泛型类型参数必须具有 length 属性
interface Lengthwise {
    length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
    console.log(arg.length);
    return arg;
}

loggingIdentity({ length: 10, value: "Hello" }); // 输出: 10
// loggingIdentity(42); // 错误: number 没有 length 属性
```

### 4. 提供更好的类型推断

泛型有助于 TypeScript 更好地推断类型，减少显式类型声明，提高开发效率。

```typescript
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
    return obj[key];
}

const person = { name: "Alice", age: 25 };
const name = getProperty(person, "name"); // 类型为 string
const age = getProperty(person, "age");   // 类型为 number
// const height = getProperty(person, "height"); // 错误: "height" 不是 person 的属性
```