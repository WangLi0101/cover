## 1. 基本定义

### 接口（Interface）

接口用于定义对象的结构，包括属性和方法。它主要用于描述对象的形状，并支持声明合并和扩展。

```typescript
interface Person {
  name: string;
  age: number;
  greet(): void;
}
```

### 类型别名（Type Alias）

类型别名用于为任何类型创建一个新的名字，包括基本类型、联合类型、元组等。它提供了一种灵活的方式来组合和构建复杂类型。

```typescript
type Person = {
  name: string;
  age: number;
  greet(): void;
};
```

## 2. 主要区别

### 2.1 可扩展性

#### 接口支持声明合并

接口可以多次声明，TypeScript 会将它们合并为一个接口。这对于扩展第三方库的接口非常有用。

```typescript
interface Person {
  name: string;
}

interface Person {
  age: number;
}

// 合并后的 Person 接口具有 name 和 age 属性
const person: Person = {
  name: "Alice",
  age: 30,
};
```

类型别名**不支持声明合并**。如果尝试多次定义相同名称的类型别名，会导致编译错误。

```typescript
type Person = {
  name: string;
};

// Error: Duplicate identifier 'Person'.
type Person = {
  age: number;
};
```

#### 接口支持扩展

接口可以通过 `extends` 关键字进行扩展，支持继承多个接口。

```typescript
interface Animal {
  species: string;
}

interface Dog extends Animal {
  breed: string;
}

const myDog: Dog = {
  species: "Canine",
  breed: "Labrador",
};
```

类型别名也可以通过交叉类型（Intersection Types）来实现类似的功能，但语法略有不同。

```typescript
type Animal = {
  species: string;
};

type Dog = Animal & {
  breed: string;
};

const myDog: Dog = {
  species: "Canine",
  breed: "Labrador",
};
```

### 2.2 功能和用途

#### 类型别名的多样性

类型别名不仅可以定义对象的结构，还可以用于定义联合类型、元组、基础类型的别名等。

```typescript
type ID = string | number;

type Point = [number, number];

type Callback = (data: string) => void;
```

接口主要用于定义对象的结构和行为，不能直接用于定义联合类型或元组等。

### 2.3 显示和推断

接口在描述对象的形状时，通常更加直观和易读，特别是在大型项目中。

```typescript
interface User {
  id: number;
  name: string;
}

const user: User = {
  id: 1,
  name: "Alice",
};
```

类型别名在需要复杂类型组合时，提供了更大的灵活性。

```typescript
type Response = SuccessResponse | ErrorResponse;

type SuccessResponse = {
  status: "success";
  data: any;
};

type ErrorResponse = {
  status: "error";
  message: string;
};
```

### 2.4 使用 `implements` 和 `extends`

接口可以被类实现（`implements`），并且可以扩展其他接口或类。

```typescript
interface Serializable {
  serialize(): string;
}

class User implements Serializable {
  constructor(public name: string) {}

  serialize() {
    return JSON.stringify(this);
  }
}
```

类型别名**不能**被类实现或扩展。它们主要用于类型的描述和组合。

## 3. 相似之处

- **描述对象的形状**：接口和类型别名都可以用来描述对象的属性和方法。

  ```typescript
  interface Car {
    make: string;
    model: string;
  }

  type CarAlias = {
    make: string;
    model: string;
  };
  ```

- **支持可选属性和只读属性**：两者都可以定义可选属性（`?`）和只读属性（`readonly`）。

  ```typescript
  interface User {
    readonly id: number;
    name?: string;
  }

  type UserAlias = {
    readonly id: number;
    name?: string;
  };
  ```

- **支持索引签名**：可以定义对象的动态属性。

  ```typescript
  interface Dictionary {
    [key: string]: any;
  }

  type DictionaryAlias = {
    [key: string]: any;
  };
  ```

## 4. 使用建议

### 4.1 优先选择接口

- **面向对象设计**：当你在设计面向对象的代码，尤其是需要类实现某些结构时，接口是更好的选择。

  ```typescript
  interface Shape {
    area(): number;
  }

  class Circle implements Shape {
    constructor(public radius: number) {}

    area() {
      return Math.PI * this.radius ** 2;
    }
  }
  ```

- **需要声明合并**：如果你需要扩展现有的接口，或者需要与第三方库的接口进行合并，接口更为适合。

### 4.2 使用类型别名

- **复杂类型组合**：当需要定义联合类型、交叉类型、元组等复杂类型时，类型别名更为灵活。

  ```typescript
  type Status = "success" | "error" | "loading";

  type ApiResponse = SuccessResponse | ErrorResponse;
  ```

- **基础类型的别名**：为基础类型创建更具描述性的名字，提高代码可读性。

  ```typescript
  type ID = string | number;

  const userId: ID = 123;
  ```

- **函数类型**：定义函数的类型签名时，类型别名更加简洁。

  ```typescript
  type Callback = (data: string) => void;

  const handleData: Callback = (data) => {
    console.log(data);
  };
  ```

## 5. 高级特性

### 5.1 映射类型

类型别名可以与映射类型结合，创建基于现有类型的变体。

```typescript
type ReadonlyUser = Readonly<User>;

type PartialUser = Partial<User>;
```

接口不能直接使用映射类型，但可以通过扩展类型别名间接实现。

### 5.2 条件类型

类型别名支持条件类型，使其在类型推断和高级类型操作中更加有用。

```typescript
type IsString<T> = T extends string ? "Yes" : "No";

type Test = IsString<number>; // "No"
type Test2 = IsString<string>; // "Yes"
```

接口无法直接使用条件类型。

### 5.3 联合与交叉类型

类型别名支持定义联合类型和交叉类型，接口不支持直接定义这些类型。

```typescript
type Shape = Circle | Square;

type Composite = TypeA & TypeB;
```

接口无法直接定义类似的联合类型。

## 7. 性能和编译

在大多数情况下，接口和类型别名在编译后的 JavaScript 代码中不会有差异，因为它们都是类型系统的一部分，不会被编译为实际的 JavaScript 代码。选择使用接口还是类型别名主要取决于代码的可读性、维护性以及具体的功能需求。
