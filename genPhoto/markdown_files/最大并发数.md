## 最大并发数
下列方法用于控制并发异步操作数量，例如3个并发同时执行
```ts
// 定义一个 Task 类型，它是一个返回 Promise 的函数，泛型 T 表示 Promise 解析后的值类型
type Task<T> = () => Promise<T>;

// 定义一个 QueueItem 类型，是一个元组，包含一个 Task 和两个回调函数（resolve 和 reject）
type QueueItem<T> = [Task<T>, (value: T) => void, (reason?: any) => void];

/**
 * PLimit 类用于限制异步任务的并发执行数量。
 * 它维护一个任务队列，并确保在任何时刻只有指定数量的任务在运行。
 */
class PLimit {
  // 最大并发数
  private concurrency: number;

  // 任务队列，存储等待执行的任务
  private queue: Array<QueueItem<any>>;

  // 当前活跃的任务数量
  private activeCount: number;

  /**
   * 构造函数，初始化 PLimit 实例。
   * @param concurrency - 最大并发数，必须是正整数
   * @throws TypeError 如果 concurrency 不是正整数
   */
  constructor(concurrency: number) {
    // 验证并发数是否为正整数
    if (!Number.isInteger(concurrency) || concurrency < 1) {
      throw new TypeError('Expected `concurrency` to be a positive integer');
    }
    this.concurrency = concurrency; // 设置最大并发数
    this.queue = []; // 初始化任务队列为空
    this.activeCount = 0; // 初始化活跃任务数为 0
  }

  /**
   * 处理下一个任务。
   * 当一个任务完成后，调用此方法减少活跃任务数，并从队列中取出下一个任务执行。
   */
  private next(): void {
    this.activeCount--; // 减少活跃任务数
    if (this.queue.length > 0) { // 如果队列中有等待的任务
      const [fn, resolve, reject] = this.queue.shift()!; // 取出队列中的第一个任务
      this.run(fn).then(resolve).catch(reject); // 运行任务并处理结果
    }
  }

  /**
   * 运行一个任务。
   * 增加活跃任务数，执行任务，处理完成后调用 next 方法。
   * @param fn - 要运行的异步任务函数
   * @returns 任务的结果
   */
  private async run<T>(fn: Task<T>): Promise<T> {
    this.activeCount++; // 增加活跃任务数
    try {
      const result = await fn(); // 执行任务并等待结果
      this.next(); // 任务完成，处理下一个任务
      return result; // 返回任务结果
    } catch (error) {
      this.next(); // 任务出错，同样处理下一个任务
      throw error; // 抛出错误以便调用者处理
    }
  }

  /**
   * 添加一个任务到限制器中。
   * 如果当前活跃任务数小于并发限制，立即执行任务。
   * 否则，将任务添加到队列中等待执行。
   * @param fn - 要执行的异步任务函数
   * @returns 任务的 Promise
   */
  public limit<T>(fn: Task<T>): Promise<T> {
    return new Promise<T>((resolve, reject) => {
      if (this.activeCount < this.concurrency) { // 检查是否有可用的并发槽
        this.run(fn).then(resolve).catch(reject); // 立即运行任务
      } else {
        this.queue.push([fn, resolve, reject]); // 添加任务到队列
      }
    });
  }
}

// 导出 PLimit 类作为默认导出
export default PLimit;
```
### 使用
```ts
// example.ts

import PLimit from './PLimit';

// 创建一个 PLimit 实例，限制并发数为 3
const limit = new PLimit(3);

// 模拟异步任务
const asyncTask = (id: number) => () =>
  new Promise<string>((resolve) => {
    console.log(`任务 ${id} 开始`);
    setTimeout(() => {
      console.log(`任务 ${id} 完成`);
      resolve(`结果 ${id}`);
    }, 1000 * id); // 不同任务不同延迟
  });

// 创建任务数组
const input = [
  asyncTask(1),
  asyncTask(2),
  asyncTask(3),
  asyncTask(4),
  asyncTask(5),
];

// 使用 limit 方法添加任务
const promises = input.map((fn) => limit.limit(fn));

Promise.all(promises).then((results) => {
  console.log('所有任务完成:', results);
});
```