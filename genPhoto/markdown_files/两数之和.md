
给定一个整数数组 `nums` 和一个整数 `target`，返回 *两个数的索引，使它们的和等于 `target`*。

你可以**假设**每个输入都只有**一个解决方案**，并且你不能两次使用相同的元素。

你可以按任意顺序返回答案。

**示例 1：**

```bash
输入: nums = [2,7,11,15], target = 9
输出: [0,1]
解释: 因为 nums[0] + nums[1] == 9，所以我们返回 [0, 1]。
```

**示例 2：**

```bash
输入: nums = [3,2,4], target = 6
输出: [1,2]
```

**示例 3：**

```bash
输入: nums = [3,3], target = 6
输出: [0,1]
```

**约束条件：**

- `2 <= nums.length <= 10^4`
- `-10^9 <= nums[i] <= 10^9`
- `-10^9 <= target <= 10^9`
- **仅存在一个有效答案。**

**进阶：** 你能想出一个时间复杂度小于 `O(n^2)` 的算法吗？

### 图解

![state](https://libra-blog.oss-cn-beijing.aliyuncs.com/src/two-sum.gif)

### 解法

#### 哈希表

我们使用一个哈希表来存储 `nums` 的值和索引。在遍历过程中，检查哈希表中是否存在 **target - nums[i]**，如果存在，则返回 **target - nums[i]** 的索引和 `i`。如果不存在，则将 `nums[i]` 的值和索引存入哈希表中。

```javascript
var twoSum = function(nums, target) {
  const map = new Map()
  for (let i = 0; i < nums.length; i++) {
    const element = nums[i];
    if (map.has(target - element)) {
      return [map.get(target - element), i]
    }
    map.set(element, i)
  }
  return []
};
```

#### 复杂度分析

时间复杂度：**O($n$)**。因为代码中有一个循环，遍历了输入数组 `nums` 的每个元素一次。这里的 `n` 是数组 `nums` 的长度。

空间复杂度：**O($n$)**。因为代码中使用了一个哈希表来存储 `nums` 的元素及其索引。在最坏的**情况**下，如果没有两个数的和等于目标值，则哈希表将存储所有的 `n` 个元素，因此空间复杂度为 **O($n$)**。3:Tae7,#### 什么是洗牌算法

